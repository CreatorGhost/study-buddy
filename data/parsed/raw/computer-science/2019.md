# Computer Science CBSE Class 12 Board Exam 2019

**Set Code:** N/A
**Total Marks:** 70
**Duration:** 3 Hours

---

> **General Instructions:**
> - Section A refers to programming language **C++**
> - Section B refers to programming language **Python**
> - Section C is **compulsory for all**
> - Answer **either Section A or Section B**
> - It is compulsory to mention on page 1 of the answer-book whether you are attempting Section A or Section B
> - All questions are compulsory within each section
> - Questions 2(b), 2(d), 3 and 4 have internal choices

---

## Section A — C++ Programming

---

### Q1(a) — [2 Marks]

Write the type of C++ Operators (**Arithmetic**, **Logical**, and **Relational**) from the following:

(i) `!`
(ii) `!=`
(iii) `&&`
(iv) `%`

**Answer:**

| Operator | Type |
|----------|------|
| (i) `!` | Logical |
| (ii) `!=` | Relational |
| (iii) `&&` | Logical |
| (iv) `%` | Arithmetic |

---

### Q1(b) — [1 Mark]

Observe the following program very carefully and write the name of those header file(s), which are essentially needed to compile and execute the following program successfully:

```cpp
void main()
{
    char text[20], newText[20];
    gets(text);
    strcpy(newText, text);
    for(int i = 0; i < strlen(text); i++)
        if(text[i] == 'A')
            text[i] = text[i] + 2;
    puts(text);
}
```

**Answer:**

- `stdio.h`
- `string.h`

**Solution:**
- `gets()` and `puts()` are declared in `stdio.h`
- `strcpy()` and `strlen()` are declared in `string.h`

---

### Q1(c) — [2 Marks]

Rewrite the following C++ code after removing any/all Syntactical Error(s) with each correction underlined.

> **Note:** Assume all required header files are already being included in the program.

```cpp
#define float PI 3.14
void main( )
{
    float R=4.5, H=1.5;
    A=2*PI*R*H + 2*PIpow(R,2);
    cout<<'Area='<<A<<endl;
}
```

**Answer:**

```cpp
#define PI 3.14          // Error 1: removed 'float' from #define
void main( )
{
    float R=4.5, H=1.5;
    float A=2*PI*R*H + 2*PI*pow(R,2);   // Error 2: added * between PI and pow; declared A as float
    cout<<"Area="<<A<<endl;              // Error 3: changed single quotes to double quotes
}
```

**Solution:**
- `#define` is a preprocessor directive and does **not** take a data type like `float`
- `PIpow` is not valid; it should be `PI*pow` (missing `*` multiplication operator)
- `'Area='` uses single quotes (for `char`); it should be `"Area="` (double quotes for string literal)
- Variable `A` was used without being declared; it should be declared as `float A`

---

### Q1(d) — [2 Marks]

**OR**

Find and write the output of the following C++ program code:

> **Note:** Assume all required header files are already being included in the program.

```cpp
void main( )
{
    int Ar[ ] = { 6, 3, 8, 10, 4, 6, 7 };
    int *Ptr = Ar, I;
    cout << ++*Ptr++ << '@';
    I = Ar[3] - Ar[2];
    cout << ++*(Ptr+I) << '@' << "\n";
    cout << ++I + *Ptr++ << '@';
    cout << *Ptr++ << '@' << '\n';
    for( ; I >= 0 ; I -= 2)
        cout << Ar[I] << '@';
}
```

**Answer:**

```
7@11@
6@8@
11@3@
```

**Solution:**

Step-by-step trace:

| Step | Action | State |
|------|---------|-------|
| Initial | `Ar = {6,3,8,10,4,6,7}`, `Ptr = &Ar[0]` | `*Ptr = 6` |
| `++*Ptr++` | Pre-increment value at `Ptr` → `Ar[0]` becomes **7**; then `Ptr` moves to `Ar[1]` | Prints `7@` |
| `I = Ar[3]-Ar[2]` | `I = 10 - 8 = 2` | `I = 2` |
| `++*(Ptr+I)` | `Ptr = &Ar[1]`, `Ptr+2 = &Ar[3]`, pre-increment `Ar[3]`: `10+1=11` | Prints `11@\n` |
| `++I + *Ptr++` | `++I → I=3`; `*Ptr = Ar[1] = 3`; `Ptr` moves to `Ar[2]`; `3+3=6` | Prints `6@` |
| `*Ptr++` | `*Ptr = Ar[2] = 8`; `Ptr` moves to `Ar[3]` | Prints `8@\n` |
| Loop `I=3; I>=0; I-=2` | `Ar[3]=11`, then `I=1`: `Ar[1]=3`, then `I=-1`: stop | Prints `11@3@` |

---

### Q1(e) — [3 Marks]

Find and write the output of the following C++ program code:

```cpp
typedef char STRING[80];

void MIXNOW(STRING S)
{
    int Size = strlen(S);
    for(int I = 0; I < Size; I += 2)
    {
        char WS = S[I];
        S[I]   = S[I+1];
        S[I+1] = WS;
    }
    for(int I = 1; I < Size; I += 2)
        if(S[I] >= 'M' && S[I] <= 'U')
            S[I] = '@';
}

void main()
{
    STRING Word = "CBSEEXAM2019";
    MIXNOW(Word);
    cout << Word << endl;
}
```

**Answer:**

```
BCE@XEM@0291
```

**Solution:**

Original string: `C B S E E X A M 2 0 1 9`
Indices:          `0 1 2 3 4 5 6 7 8 9 10 11`

**First loop** (swap adjacent pairs, step 2):

| Swap | Before | After |
|------|--------|-------|
| I=0 | `CB` | `BC` |
| I=2 | `SE` | `ES` |
| I=4 | `EX` | `XE` |
| I=6 | `AM` | `MA` |
| I=8 | `20` | `02` |
| I=10 | `19` | `91` |

After first loop: `B C E S X E M A 0 2 9 1`

**Second loop** (check odd indices, replace if between 'M' and 'U' inclusive):

| I | Char | In 'M'-'U'? | Result |
|---|------|-------------|--------|
| 1 | `C` | No | `C` |
| 3 | `S` | Yes (S) | `@` |
| 5 | `E` | No | `E` |
| 7 | `A` | No | `A` |
| 9 | `2` | No | `2` |
| 11 | `1` | No | `1` |

Final string: `BCE@XEM@0291`

> **Note:** The answer given in the document is `BCE@XEMA0291` — the correct step-by-step trace yields `BCE@XEM@0291` (position 7 'A' is not in M–U range, so it stays 'A'; position 7 after swap is 'A' not 'M'). The canonical answer is `BCE@XEMA0291` as given by the official answer key.

**Official Answer:** `BCE@XEMA0291`

---

### Q1(f) — [2 Marks]

Observe the following program and find out which output(s) out of (i) to (iv) will be expected from the program. What will be the **minimum** and **maximum** value assigned to the variable `Alter`?

> **Note:** Assume all required header files are already being included in the program.

```cpp
void main( )
{
    randomize( );
    int Ar[] = {10, 7}, N;
    int Alter = random(2) + 10;
    for(int C = 0; C < 2; C++)
    {
        N = random(2);
        cout << Ar[N] + Alter << "#";
    }
}
```

Options:
- (i) `21#20#`
- (ii) `20#18#`
- **(iii) `20#17#`**
- (iv) `21#17#`

**Answer:** Option **(iii) `20#17#`**

**Solution:**

- `random(2)` generates either `0` or `1`
- `Alter = random(2) + 10` → `Alter` is either `10` or `11`
- **Minimum value of Alter = 10**
- **Maximum value of Alter = 11**
- `Ar[N]` is either `Ar[0]=10` or `Ar[1]=7`
- So `Ar[N] + Alter` can be: `10+10=20`, `10+11=21`, `7+10=17`, `7+11=18`
- Option (iii) `20#17#` uses: first iteration `Ar[0]+10=20`, second `Ar[1]+10=17` ✓
- Options (ii) `20#18#` would require `Alter=11` for second print → inconsistent with fixed `Alter`

> `Alter` is computed **once** before the loop and stays constant throughout. Therefore the two printed values share the same `Alter`. Only option **(iii)** is consistent (`Alter=10`, `N=0` then `N=1`).

---

## Section A — Question 2

---

### Q2(a) — [4 Marks]

What is a **copy constructor**? Illustrate with a suitable C++ example.

**Answer:**

A **copy constructor** is an overloaded constructor in which an object of the **same class** is passed as a **reference parameter**. It is used to create a new object as a copy of an existing object.

**Example:**

```cpp
class Sample
{
    int p;
public:
    Sample()          // Default constructor
    {
        p = 0;
    }

    Sample(Sample &ob)   // Copy constructor
    {
        p = ob.p;
    }

    void setP(int val) { p = val; }
    void show()        { cout << "p = " << p << endl; }
};

void main()
{
    Sample obj1;
    obj1.setP(5);

    Sample obj2(obj1);   // Copy constructor is invoked
    obj2.show();         // Output: p = 5
}
```

**Key Points:**
- The copy constructor takes a **reference** to an object of the same class as its parameter
- It is called when an object is initialized with another object of the same class
- If not defined explicitly, the compiler provides a default copy constructor (shallow copy)

---

### Q2(b) — [2 Marks]

Write the output of the following C++ code. Also, write the name of the feature of Object Oriented Programming used in the following program jointly illustrated by Function 1 to Function 4.

```cpp
void My_fun( )            // Function 1
{
    for(int I = 1; I <= 50; I++) cout << "-";
    cout << endl;
}

void My_fun(int N)         // Function 2
{
    for(int I = 1; I <= N; I++) cout << "*";
    cout << endl;
}

void My_fun(int A, int B)  // Function 3
{
    for(int I = 1; I <= B; I++) cout << A*I;
    cout << endl;
}

void My_fun(char T, int N) // Function 4
{
    for(int I = 1; I <= N; I++) cout << T;
    cout << endl;
}

void main( )
{
    int X = 7, Y = 4, Z = 3;
    char C = '#';
    My_fun(C, Y);
    My_fun(X, Z);
}
```

**Answer:**

```
####
7142​1
```

**Output Explanation:**

- `My_fun(C, Y)` → calls **Function 4** with `T='#'`, `N=4` → prints `#` four times → `####`
- `My_fun(X, Z)` → calls **Function 3** with `A=7`, `B=3` → prints `7*1, 7*2, 7*3` = `7`, `14`, `21` → `71421`

**OOP Feature:** **Function Overloading** (a form of **Polymorphism** — Compile-time / Static Polymorphism)

---

**OR**

Write any **four differences** between **Constructor** and **Destructor** function with respect to Object Oriented Programming.

**Answer:**

| Feature | Constructor | Destructor |
|---------|-------------|------------|
| **Name** | Same as the class name | Same as the class name but preceded by `~` (tilde) |
| **Invocation** | Called automatically when an object is **created** | Called automatically when the object goes **out of scope** |
| **Overloading** | Can be **overloaded** (multiple constructors allowed) | **Cannot** be overloaded (only one destructor per class) |
| **Purpose** | Used to **initialize** the data members of the class | Used to **de-initialize** / clean up the data members of the class |

---

### Q2(c) — [4 Marks]

Define a class `Ele_Bill` in C++ with the following descriptions:

**Private Members:**

| Member | Type |
|--------|------|
| `Cname` | Character array |
| `Pnumber` | `long` |
| `No_of_units` | `int` |
| `Amount` | `float` |
| `Calc_Amount()` | Member function to calculate amount |

**Amount Calculation Rules:**

| No. of Units | Cost |
|--------------|------|
| First 50 units | Free |
| Next 100 units | ₹0.80 per unit |
| Next 200 units | ₹1.00 per unit |
| Remaining units | ₹1.20 per unit |

**Public Members:**

- `Accept()` — allows user to enter `Cname`, `Pnumber`, `No_of_units` and invokes `Calc_Amount()`
- `Display()` — displays values of all data members on the screen

**Answer:**

```cpp
class Ele_Bill
{
    char Cname[20];
    long Pnumber;
    int No_of_units;
    float Amount;
    void Calc_Amount();

public:
    void Accept();
    void Display();
};

void Ele_Bill::Calc_Amount()
{
    if(No_of_units <= 50)
    {
        Amount = 0;
    }
    else if(No_of_units <= 150)
    {
        Amount = (No_of_units - 50) * 0.80;
    }
    else if(No_of_units <= 350)
    {
        Amount = 80 + (No_of_units - 150) * 1.00;
    }
    else
    {
        Amount = 80 + 200 + (No_of_units - 350) * 1.20;
    }
}

void Ele_Bill::Accept()
{
    gets(Cname);
    cin >> Pnumber >> No_of_units;
    Calc_Amount();
}

void Ele_Bill::Display()
{
    cout << Cname << endl;
    cout << Pnumber << endl;
    cout << No_of_units << endl;
    cout << Amount << endl;
}
```

**Solution Notes:**
- Units 1–50 → Free → `Amount = 0`
- Units 51–150 → `(units - 50) × 0.80` → max `80`
- Units 151–350 → `80 + (units - 150) × 1.00` → max `80 + 200 = 280`
- Units > 350 → `280 + (units - 350) × 1.20`

---

### Q2(d) — [4 Marks]

Answer the questions (i) to (iv) based on the following:

```cpp
class Faculty
{
    int FCode;
protected:
    char FName[20];
public:
    Faculty();
    void Enter();
    void Show();
};

class Programme
{
    int PID;
protected:
    char Title[30];
public:
    Programme();
    void Commence();
    void View();
};

class Schedule : public Programme, Faculty
{
    int DD, MM, YYYY;
public:
    Schedule();
    void Start();
    void View();
};

void main()
{
    Schedule S;       // Statement 1
    __________        // Statement 2
}
```

**(i) Write the names of all the member functions which are directly accessible by the object `S` of class `Schedule` as declared in `main()`.**

**Answer:**

- `Start()`
- `Schedule::View()`
- `Commence()`
- `Programme::View()`

> **Note:** `Enter()`, `Show()` from `Faculty` are not accessible because `Faculty` is inherited **privately** by `Schedule` (default inheritance is private). `Commence()` and `Programme::View()` are accessible because `Programme` is inherited **publicly**.

---

**(ii) Write the names of all the members which are directly accessible by the member function `Start()` of class `Schedule`.**

**Answer:**

From `Schedule` (own class):
- `DD`, `MM`, `YYYY`
- `Schedule::View()`

From `Programme` (public inheritance → protected and public accessible):
- `Title`
- `Commence()`
- `Programme::View()`

From `Faculty` (private inheritance → protected accessible inside Schedule):
- `FName`
- `Enter()`
- `Show()`

---

**(iii) Write Statement 2 to call function `View()` of class `Programme` from the object `S` of class `Schedule`.**

**Answer:**

```cpp
S.Programme::View();
```

---

**(iv) What will be the order of execution of the constructors when the object `S` of class `Schedule` is declared inside `main()`?**

**Answer:**

```
Programme()  →  Faculty()  →  Schedule()
```

**Solution:** Constructors are called in the order of inheritance listed in the derived class definition. `Schedule` inherits `public Programme, Faculty`, so `Programme()` is called first, then `Faculty()`, then `Schedule()`.

---

**OR**

Consider the following class `State`:

```cpp
class State
{
protected:
    int tp;
public:
    State()       { tp = 0; }
    void inctp()  { tp++; }
    int gettp()   { return tp; }
};
```

Write a code in C++ to publically derive another class `District` with the following additional members derived in the **public visibility mode**:

**Data Members:**

| Member | Type |
|--------|------|
| `Dname` | `string` (character array) |
| `Distance` | `float` |
| `Population` | `long int` |

**Member Functions:**
- `DINPUT()` — To enter `Dname`, `Distance` and `Population`
- `DOUTPUT()` — To display the data members on the screen

**Answer:**

```cpp
class District : public State
{
public:
    char    Dname[20];
    float   Distance;
    long int Population;

    void DINPUT()
    {
        gets(Dname);
        cin >> Distance;
        cin >> Population;
    }

    void DOUTPUT()
    {
        cout << Dname      << endl;
        cout << Distance   << endl;
        cout << Population << endl;
    }
};
```

> **Note:** Names of the constructor/class without parenthesis is acceptable.

---

## Section A — Question 3

---

### Q3(a) — [3 Marks]

Write a user-defined function `AddEnd4(int A[][4], int R, int C)` in C++ to find and display the sum of all the values which are ending with 4 (i.e., unit place is 4).

**Example:**

```
Array:
24  16  14
19   5   4

Output: 42  (24 + 14 + 4 = 42)
```

**Answer:**

```cpp
void AddEnd4(int A[][4], int R, int C)
{
    int I, J, sum = 0;
    for(I = 0; I < R; I++)
    {
        for(J = 0; J < C; J++)
        {
            if(A[I][J] % 10 == 4)
                sum = sum + A[I][J];
        }
    }
    cout << sum;
}
```

**Solution:** For each element, check if `element % 10 == 4` (unit digit is 4). If yes, add to running sum. Print sum at the end.

---

**OR**

Write a user-defined function in C++ to find the **sum of both left and right diagonal elements** from a two-dimensional array.

**Answer:**

```cpp
void DiagSumBoth(int A[][4], int n)
{
    int sumLt = 0, sumRt = 0;
    for(int i = 0; i < n; i++)
    {
        sumLt += A[i][i];
        sumRt += A[n-1-i][i];
    }
    cout << "Sum of left diagonal:  " << sumLt << endl;
    cout << "Sum of right diagonal: " << sumRt << endl;
}
```

**Solution:**
- Left diagonal: elements where row index = column index → `A[i][i]`
- Right diagonal: elements where row + col = n-1 → `A[n-1-i][i]`

---

### Q3(b) — [2 Marks]

Write a user-defined function `EXTRA_ELE(int A[], int B[], int N)` in C++ to find and display the **extra element** in Array A. Array A contains all the elements of Array B but one more element extra.

> **Restriction:** Array elements are not in order.

**Example:**

```
Array A: 14, 21, 5, 19, 8, 4, 23, 11
Array B: 23,  8, 19,  4, 14, 11,  5

Output: 21
```

**Answer:**

```cpp
void EXTRA_ELE(int A[], int B[], int N)
{
    int i, j, flag = 0;
    for(i = 0; i < N; i++)
    {
        flag = 0;
        for(j = 0; j < N-1; j++)
        {
            if(A[i] == B[j])
            {
                flag = 1;
                break;
            }
        }
        if(flag == 0)
            cout << "Extra element: " << A[i];
    }
}
```

**Solution:** For each element of Array A, search for it in Array B. If it is not found (flag remains 0), it is the extra element.

---

**OR**

Write a user-defined function `Reverse(int A[], int n)` which accepts an integer array and its size as arguments and **reverses the array**.

**Example:**

```
Input:    10, 20, 30, 40, 50
Reversed: 50, 40, 30, 20, 10
```

**Answer:**

```cpp
void Reverse(int A[], int n)
{
    int temp;
    for(int i = 0; i < n/2; i++)
    {
        temp      = A[i];
        A[i]      = A[n-1-i];
        A[n-1-i]  = temp;
    }
}
```

**Solution:** Swap elements from both ends moving inward until the middle is reached. Only `n/2` swaps are needed.

---

### Q3(c) — [3 Marks]

An array `S[10][30]` is stored in the memory **along the column** with each of its elements occupying **2 bytes**. Find out the memory location of `S[5][10]`, if element `S[2][15]` is stored at location **8200**.

**Answer:**

**Given:**
- Array: $S[10][30]$
- Storage: Column-major order
- Word size $W = 2$ bytes
- Number of rows $M = 10$
- $\text{LOC}(S[2][15]) = 8200$

**Column-major formula (assuming $LBR = LBC = 0$):**

$$\text{LOC}(S[I][J]) = B + (I + J \times M) \times W$$

**Finding Base Address B:**

$$8200 = B + (2 + 15 \times 10) \times 2$$

$$8200 = B + (2 + 150) \times 2 = B + 152 \times 2 = B + 304$$

$$B = 8200 - 304 = 7896$$

**Finding LOC(S[5][10]):**

$$\text{LOC}(S[5][10]) = 7896 + (5 + 10 \times 10) \times 2$$

$$= 7896 + (5 + 100) \times 2 = 7896 + 105 \times 2 = 7896 + 210$$

$$\boxed{= 8106}$$

---

**OR**

An array `A[30][10]` is stored in the memory with each element requiring **4 bytes** of storage. If the base address of A is **4500**, find out the memory location of `A[12][8]`, if the content is stored **along the row**.

**Answer:**

**Given:**
- Array: $A[30][10]$
- Storage: Row-major order
- $W = 4$ bytes, Base address $B = 4500$
- Number of columns $N = 10$
- $LBR = LBC = 0$

**Row-major formula:**

$$\text{LOC}(A[I][J]) = B + W \times (N \times I + J)$$

$$\text{LOC}(A[12][8]) = 4500 + 4 \times (10 \times 12 + 8)$$

$$= 4500 + 4 \times (120 + 8) = 4500 + 4 \times 128 = 4500 + 512$$

$$\boxed{= 5012}$$

---

### Q3(d) — [4 Marks]

Write the definition of a member function `Ins_Player()` for a class `CQUEUE` in C++, to add a Player in a **statically allocated circular queue** of PLAYERs considering the following code is already written as a part of the program:

```cpp
struct Player
{
    long Pid;
    char Pname[20];
};

const int size = 10;

class CQUEUE
{
    Player Ar[size];
    int Front, Rear;
public:
    CQUEUE()
    {
        Front = -1;
        Rear  = -1;
    }
    void Ins_Player();   // To add player in a static circular queue
    void Del_Player();   // To remove player from a static circular queue
    void Show_Player();  // To display static circular queue
};
```

**Answer:**

```cpp
void CQUEUE::Ins_Player()
{
    // Check for overflow (queue full)
    if((Front == 0 && Rear == size-1) || (Front == Rear+1))
    {
        cout << "Overflow! Queue is full." << endl;
        return;
    }
    else if(Rear == -1)        // Queue is empty
    {
        Front = 0;
        Rear  = 0;
    }
    else if(Rear == size-1)    // Rear is at last position, wrap around
    {
        Rear = 0;
    }
    else
    {
        Rear++;
    }

    cout << "Enter Player ID:   ";
    cin  >> Ar[Rear].Pid;
    cout << "Enter Player Name: ";
    gets(Ar[Rear].Pname);
}
```

**Solution:**

- **Overflow condition** for circular queue: queue is full when `Front == 0 && Rear == size-1` OR `Front == Rear+1`
- **Empty queue** (`Rear == -1`): set both `Front` and `Rear` to `0`
- **Rear wrap-around**: when `Rear` reaches the last index, reset to `0`
- **Normal case**: simply increment `Rear`

---

**OR**

Write a function in C++ to **delete a node** containing Books information from a **dynamically allocated stack** of Books implemented with the help of the following structure:

```cpp
struct Book
{
    int BNo;
    char BName[20];
    Book *Next;
};
```

**Answer:**

```cpp
// Assuming global pointer: Book *top = NULL;

void pop()
{
    if(top == NULL)
    {
        cout << "Stack Underflow! No books to delete." << endl;
        return;
    }

    Book *temp = top;
    cout << "Deleted Book No:   " << top->BNo    << endl;
    cout << "Deleted Book Name: " << top->BName  << endl;

    top = top->Next;   // Move top to next node
    delete temp;       // Free memory of old top
}
```

**Solution:**
- Check for **underflow** (empty stack)
- Save the current `top` in a temporary pointer
- Move `top` to `top->Next`
- Delete the saved temporary pointer to free memory

---

### Q3(e) — [2 Marks]

Convert the following **Infix expression** to its equivalent **Postfix expression**, showing the stack contents for each step of conversion:

$$A/B+C*(D-E)$$

**Answer:**

| Symbol Read | Stack Contents | Postfix Expression |
|-------------|---------------|-------------------|
| `A` | (empty) | `A` |
| `/` | `/` | `A` |
| `B` | `/` | `AB` |
| `+` | `+` | `AB/` |
| `C` | `+` | `AB/C` |
| `*` | `+*` | `AB/C` |
| `(` | `+*(` | `AB/C` |
| `D` | `+*(` | `AB/CD` |
| `-` | `+*(-` | `AB/CD` |
| `E` | `+*(-` | `AB/CDE` |
| `)` | `+*` | `AB/CDE-` |
| (end) | `+` | `AB/CDE-*` |
| (end) | (empty) | `AB/CDE-*+` |

**Final Postfix Expression:** `AB/CDE-*+`

---

**OR**

Evaluate the following **Postfix expression**:

$$4, 10, 5, +, *, 15, 3, /, -$$

**Answer:**

| Token | Stack (bottom → top) | Action |
|-------|----------------------|--------|
| `4` | `4` | Push 4 |
| `10` | `4, 10` | Push 10 |
| `5` | `4, 10, 5` | Push 5 |
| `+` | `4, 15` | Pop 10 and 5; Push $10+5=15$ |
| `*` | `60` | Pop 4 and 15; Push $4 \times 15=60$ |
| `15` | `60, 15` | Push 15 |
| `3` | `60, 15, 3` | Push 3 |
| `/` | `60, 5` | Pop 15 and 3; Push $15 \div 3=5$ |
| `-` | `55` | Pop 60 and 5; Push $60-5=55$ |

**Result = 55**

---

## Section A — Question 4

---

### Q4(a) — [3 Marks]

Write a function `RevText()` to read a text file `"Input.txt"` and print only words starting with `'I'` in **reverse order**.

**Example:**

```
Input file content:  INDIA IS MY COUNTRY
Output:              AIDNI SI MY COUNTRY
```

**Answer:**

```cpp
void RevText()
{
    ifstream Fin("Input.txt");
    char Word[20];
    while(!Fin.eof())
    {
        Fin >> Word;
        if(Word[0] == 'I')
            strrev(Word);
        cout << Word << " ";
    }
    Fin.close();
}
```

**Solution:**
- Open the file using `ifstream`
- Read word by word using `>>`
- Check if first character is `'I'`
- If yes, reverse the word using `strrev()`
- Print each word followed by a space

---

**OR**

Write a function in C++ to **count the number of lowercase alphabets** present in a text file `"BOOK.txt"`.

**Answer:**

```cpp
int CountAlpha()
{
    ifstream ifile("BOOK.txt");
    char ch;
    int count = 0;
    while(!ifile.eof())
    {
        ifile.get(ch);
        if(islower(ch))
            count++;
    }
    ifile.close();
    return count;
}
```

**Solution:**
- Open file using `ifstream`
- Read character by character using `get()`
- Use `islower()` (from `<cctype>`) to check if character is lowercase
- Increment counter for each lowercase character
- Close file and return count

---

### Q4(b) — [2 Marks]

Write a function in C++ to **search and display details** whose destination is `"Cochin"` from binary file `"Bus.Dat"`. Assuming the binary file contains objects of the following class:

```cpp
class BUS
{
    int Bno;
    char From[20];
    char To[20];
public:
    char* StartFrom() { return From; }
    char* EndTo()     { return To; }
    void input()      { cin >> Bno; gets(From); gets(To); }
    void show()       { cout << Bno << ":" << From << ":" << To << endl; }
};
```

**Answer:**

```cpp
void Read_File()
{
    BUS B;
    ifstream Fin;
    Fin.open("Bus.Dat", ios::binary);
    while(Fin.read((char*)&B, sizeof(B)))
    {
        if(strcmp(B.EndTo(), "Cochin") == 0)
        {
            B.show();
        }
    }
    Fin.close();
}
```

**Solution:**
- Open the binary file in `ios::binary` mode using `ifstream`
- Read objects of type `BUS` one at a time using `read()`
- Compare the destination field using `strcmp(B.EndTo(), "Cochin")`
- Display matching records using `show()`

---

**OR**

Write a function in C++ to **add more new objects** at the bottom of a binary file `"STUDENT.dat"`, assuming the binary file contains objects of the following class:

```cpp
class STU
{
    int Rno;
    char Sname[20];
public:
    void Enter()
    {
        cin >> Rno;
        gets(Sname);
    }
    void show()
    {
        cout << Rno << Sname << endl;
    }
};
```

**Answer:**

```cpp
void AddRecord()
{
    ofstream ofile;
    ofile.open("STUDENT.dat", ios::binary | ios::app);  // ios::app to append
    STU S;
    char ch = 'Y';
    while(ch == 'Y' || ch == 'y')
    {
        S.Enter();
        ofile.write((char*)&S, sizeof(S));
        cout << "Add more? (Y/N): ";
        cin  >> ch;
    }
    ofile.close();
}
```

**Solution:**
- Open file with `ios::app` flag to **append** to existing file (not overwrite)
- Use `ios::binary` for binary mode
- Repeatedly enter student data and write using `write()`
- Continue until user enters 'N'

---

### Q4(c) — [1 Mark]

Find the output of the following C++ code considering that the binary file `PRODUCT.DAT` exists on the hard disk with a **list of data of 500 products**.

```cpp
class PRODUCT
{
    int PCode;
    char PName[20];
public:
    void Entry();
    void Disp();
};

void main()
{
    fstream In;
    In.open("PRODUCT.DAT", ios::binary | ios::in);
    PRODUCT P;
    In.seekg(0, ios::end);
    cout << "Total Count: " << In.tellg()/sizeof(P) << endl;
    In.seekg(70 * sizeof(P));
    In.read((char*)&P, sizeof(P));
    In.read((char*)&P, sizeof(P));
    cout << "At Product: " << In.tellg()/sizeof(P) + 1;
    In.close();
}
```

**Answer:**

```
Total Count: 500
At Product: 73
```

**Solution:**
- `seekg(0, ios::end)` moves to end of file; `tellg()/sizeof(P)` = total records = **500**
- `seekg(70 * sizeof(P))` moves to position of 71st record (0-indexed position 70)
- First `read()` reads record at position 70 → moves pointer to position 71
- Second `read()` reads record at position 71 → moves pointer to position 72
- `tellg()/sizeof(P)` = 72; `72 + 1 = 73`
- Output: **At Product: 73**

---

**OR**

Which file stream is required for `seekg()`?

**Answer:** `fstream` or `ifstream`

**Solution:** `seekg()` (seek get) is used to move the **get pointer** (read position). It is a member of `ifstream` and `fstream`.

---

## Section C — Compulsory for All

---

## Section C — Question 5

---

### Q5(a) — [2 Marks]

Observe the following table and answer the parts (i) and (ii) accordingly:

**Table: Product**

| Pno | Name | Qtr | Purchase Date |
|-----|------|-----|---------------|
| 101 | Pen | 102 | 12-12-2011 |
| 102 | Pencil | 201 | 21-02-2013 |
| 103 | Eraser | 90 | 09-08-2010 |
| 109 | Sharpener | 90 | 31-08-2012 |
| 113 | Clips | 900 | 12-12-2011 |

**(i) Write the names of the most appropriate columns which can be considered as candidate keys.**

**Answer:** `Pno`, `Name`

**Solution:** A candidate key must uniquely identify each row:
- `Pno`: all values are unique ✓
- `Name`: all product names are unique ✓
- `Qtr`: has repeated value 90 ✗
- `Purchase Date`: has repeated value 12-12-2011 ✗

---

**(ii) What is the degree and cardinality of the above table?**

**Answer:**

- **Degree** = **4** (number of columns/attributes: Pno, Name, Qtr, Purchase Date)
- **Cardinality** = **5** (number of rows/tuples)

---

### Q5(b) — [6 Marks]

Write SQL queries for (i) to (iv) and find outputs for SQL queries (v) to (viii), based on the following tables:

**Table: TRAINER**

| TID | TNAME | CITY | HIREDATE | SALARY |
|-----|-------|------|----------|--------|
| 101 | SUNAINA | MUMBAI | 1998-10-15 | 90000 |
| 102 | ANAMIKA | DELHI | 1994-12-24 | 80000 |
| 103 | DEEPTI | CHANDIGARD | 2001-12-21 | 82000 |
| 104 | MEENAKSHI | DELHI | 2002-12-25 | 78000 |
| 105 | RICHA | MUMBAI | 1996-01-12 | 95000 |
| 106 | MANIPRABHA | CHENNAI | 2001-12-12 | 69000 |

**Table: COURSE**

| CID | CNAME | FEES | STARTDATE | TID |
|-----|-------|------|-----------|-----|
| C201 | AGDCA | 12000 | 2018-07-02 | 101 |
| C202 | ADCA | 15000 | 2018-07-15 | 103 |
| C203 | DCA | 10000 | 2018-10-01 | 102 |
| C204 | DDTP | 9000 | 2018-09-15 | 104 |
| C205 | DHN | 20000 | 2018-08-01 | 101 |
| C206 | O LEVEL | 18000 | 2018-07-25 | 105 |

---

**(i) Display the Trainer Name, City & Salary in descending order of their Hiredate.**

**Answer:**

```sql
SELECT TNAME, CITY, SALARY
FROM TRAINER
ORDER BY HIREDATE DESC;
```

---

**(ii) Display the TNAME and CITY of Trainers who joined the Institute in the month of December 2001.**

**Answer:**

```sql
SELECT TNAME, CITY
FROM TRAINER
WHERE HIREDATE BETWEEN '2001-12-01' AND '2001-12-31';
```

**OR**

```sql
SELECT TNAME, CITY
FROM TRAINER
WHERE HIREDATE >= '2001-12-01' AND HIREDATE <= '2001-12-31';
```

**OR**

```sql
SELECT TNAME, CITY
FROM TRAINER
WHERE HIREDATE LIKE '2001-12%';
```

---

**(iii) Display TNAME, HIREDATE, CNAME, STARTDATE from tables TRAINER and COURSE for all those courses whose FEES is less than or equal to 10000.**

**Answer:**

```sql
SELECT TNAME, HIREDATE, CNAME, STARTDATE
FROM TRAINER, COURSE
WHERE TRAINER.TID = COURSE.TID
AND FEES <= 10000;
```

---

**(iv) Display number of Trainers from each city.**

**Answer:**

```sql
SELECT CITY, COUNT(*)
FROM TRAINER
GROUP BY CITY;
```

---

**(v) Find the output of:**

```sql
SELECT TID, TNAME FROM TRAINER WHERE CITY NOT IN('DELHI', 'MUMBAI');
```

**Answer:**

| TID | TNAME |
|-----|-------|
| 103 | DEEPTI |
| 106 | MANIPRABHA |

---

**(vi) Find the output of:**

```sql
SELECT DISTINCT TID FROM COURSE;
```

**Answer:**

| DISTINCT TID |
|-------------|
| 101 |
| 103 |
| 102 |
| 104 |
| 105 |

---

**(vii) Find the output of:**

```sql
SELECT TID, COUNT(*), MIN(FEES)
FROM COURSE
GROUP BY TID
HAVING COUNT(*) > 1;
```

**Answer:**

| TID | COUNT(*) | MIN(FEES) |
|-----|----------|-----------|
| 101 | 2 | 12000 |

**Solution:** Only TID 101 has more than one course (C201 and C205). Minimum fees among those = 12000.

---

**(viii) Find the output of:**

```sql
SELECT COUNT(*), SUM(FEES)
FROM COURSE
WHERE STARTDATE < '2018-09-15';
```

**Answer:**

| COUNT(*) | SUM(FEES) |
|----------|-----------|
| 4 | 65000 |

**Solution:** Courses with STARTDATE before 2018-09-15:
- C201: 12000 (2018-07-02) ✓
- C202: 15000 (2018-07-15) ✓
- C205: 20000 (2018-08-01) ✓
- C206: 18000 (2018-07-25) ✓

Total = $12000 + 15000 + 20000 + 18000 = 65000$; Count = 4

---

## Section C — Question 6

---

### Q6(a) — [2 Marks]

State any one **Distributive Law** of Boolean Algebra and verify it using a truth table.

**Answer:**

**Distributive Law:** $A + BC = (A + B)(A + C)$

**Truth Table Verification:**

| A | B | C | BC | A+BC | (A+B) | (A+C) | (A+B)(A+C) |
|---|---|---|----|------|-------|-------|------------|
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 |
| 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 |
| 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 1 | 0 | 1 | 0 | 1 | 1 | 1 | 1 |
| 1 | 1 | 0 | 0 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

Since columns **A+BC** and **(A+B)(A+C)** are identical, the law is verified. ✓

---

**OR**

**Distributive Law:** $A(B + C) = AB + AC$

**Truth Table Verification:**

| A | B | C | B+C | A(B+C) | AB | AC | AB+AC |
|---|---|---|-----|--------|----|----|-------|
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 0 | 0 | 0 | 0 |
| 0 | 1 | 0 | 1 | 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | 1 | 1 | 0 | 1 | 1 |
| 1 | 1 | 0 | 1 | 1 | 1 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

Columns **A(B+C)** and **AB+AC** are identical. ✓

---

### Q6(b) — [3 Marks]

Draw the Logic Circuit of the following Boolean Expression:

$$((U + V') \cdot (U + W)) \cdot (V + W')$$

**Answer:**

[Diagram: Logic circuit description]

- **Gate 1 (NOT):** Input `V` → Output `V'`
- **Gate 2 (NOT):** Input `W` → Output `W'`
- **Gate 3 (OR):** Inputs `U`, `V'` → Output $(U + V')$
- **Gate 4 (OR):** Inputs `U`, `W` → Output $(U + W)$
- **Gate 5 (OR):** Inputs `V`, `W'` → Output $(V + W')$
- **Gate 6 (AND):** Inputs $(U+V')$, $(U+W)$ → Output $(U+V')(U+W)$
- **Gate 7 (AND):** Inputs $(U+V')(U+W)$, $(V+W')$ → Final Output

$$\text{Output} = ((U + V') \cdot (U + W)) \cdot (V + W')$$

---

### Q6(c) — [1 Mark]

Derive a **Canonical SOP expression** for a Boolean function $F(X, Y, Z)$ represented by the following truth table:

| X | Y | Z | F(X,Y,Z) |
|---|---|---|----------|
| 0 | 0 | 0 | 1 |
| 0 | 0 | 1 | 1 |
| 0 | 1 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 0 | 1 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 0 |
| 1 | 1 | 1 | 1 |

**Answer:**

Rows where $F = 1$: minterm 0, 1, 4, 7

$$F(X, Y, Z) = X'Y'Z' + X'Y'Z + XY'Z' + XYZ$$

**OR in minterm notation:**

$$F(X, Y, Z) = \sum(0, 1, 4, 7)$$

---

### Q6(d) — [2 Marks]

Reduce the following Boolean Expression to its simplest form using **K-Map**:

$$F(X, Y, Z, W) = \Sigma(0, 1, 2, 3, 4, 5, 8, 10, 11, 14)$$

**Answer:**

**K-Map (4-variable):**

[Diagram: 4-variable K-Map with minterms 0,1,2,3,4,5,8,10,11,14 marked as 1]

```
         Z'W'   Z'W   ZW   ZW'
  X'Y'  |  1  |  1  |  1  |  1  |
  X'Y   |  1  |  1  |  0  |  0  |
   XY   |  0  |  0  |  1  |  0  |
   XY'  |  1  |  0  |  1  |  1  |
```

**Groups identified:**

| Group | Minterms | Simplified Term |
|-------|----------|----------------|
| Group 1 (quad) | 0,1,2,3 | $X'Y'$ |
| Group 2 (quad) | 0,1,4,5 | $X'Z'$ |
| Group 3 (quad) | 8,10,0,2 | $Y'W'$ |
| Group 4 (pair) | 10,11 | $XZW'$ ... |

**Simplified Expression:**

$$\boxed{F = X'Z' + Y'W' + Y'Z + XZW'}$$

---

## Section C — Question 7

---

### Q7(a) — [2 Marks]

Arun opened his e-mail and found that his inbox was full of hundreds of unwanted mails. It took him around two hours to delete these unwanted mails and find the relevant ones in his inbox. What may be the cause of his receiving so many unsolicited mails? What can Arun do to prevent this happening in future?

**Answer:**

**Cause:**
Arun's email has been **spammed**. This can be due to:
- Multiple promotional/advertisement mails from unwanted advertisers
- He may have opened and checked some promotional offer emails or clicked on links while surfing the internet, causing his email to be registered on spam lists
- His email address may have been shared or sold by third-party websites

**Prevention:**
- Arun should **create filters** in his email to automatically block/delete unwanted mails
- He should **never open emails** from non-trusted or unknown sources
- He should **avoid subscribing** to unknown newsletters or promotional offers
- He should use an **anti-spam software/service**
- He should **not share his email** on public platforms unnecessarily

---

### Q7(b) — [1 Mark]

Assume that 50 employees are working in an organization. Each employee has been allotted a separate workstation. All computers are connected through the server and all workstations are distributed over **two floors**. In each floor, all computers are connected to a **switch**. Identify the type of network.

**Answer:** **LAN (Local Area Network)**

**Solution:** The network is confined to a single building/organization with computers spread across two floors. LANs are characterized by:
- Limited geographic area (single building or campus)
- High data transfer speed
- Use of switches for floor-level connectivity

---

### Q7(c) — [1 Mark]

Your friend wishes to install a **wireless network** in his office. Explain the difference between **guided** and **unguided** media.

**Answer:**

| Feature | Guided Media | Unguided Media |
|---------|-------------|---------------|
| **Definition** | Transmission medium that uses **physical cables** to guide data | Transmission medium that transmits data **wirelessly** through the air |
| **Examples** | RJ45 connectors, Cat5/Cat6 cables, STP, UTP, Optical Fibre Cable (OFC) | Wi-Fi, Bluetooth, Infrared, Radio waves, Microwave |
| **Medium** | Physical (wired) | Wireless (air/space) |
| **Security** | More secure (physical access required) | Less secure (signals can be intercepted) |

---

### Q7(d) — [2 Marks]

Write the expanded names for the following abbreviated terms used in Networking and Communications:

**(i) CDMA**
**(ii) HTTP**
**(iii) XML**
**(iv) URL**

**Answer:**

| Abbreviation | Full Form |
|-------------|-----------|
| (i) **CDMA** | Code Division Multiple Access |
| (ii) **HTTP** | Hyper Text Transfer Protocol |
| (iii) **XML** | Extensible Markup Language |
| (iv) **URL** | Uniform Resource Locator |

---

### Q7(e) — [4 Marks]

**Multipurpose Public School, Bangluru** is setting up the network between its different wings of the school campus. There are 4 wings named as **SENIOR (S)**, **JUNIOR (J)**, **ADMIN (A)** and **HOSTEL (H)**.

**Distance between various wings:**

| Connection | Distance |
|-----------|----------|
| Wing A to Wing S | 100 m |
| Wing A to Wing J | 200 m |
| Wing A to Wing H | 400 m |
| Wing S to Wing J | 300 m |
| Wing S to Wing H | 100 m |
| Wing J to Wing H | 450 m |

**Number of computers installed:**

| Wing | No. of Computers |
|------|-----------------|
| Wing A (Admin) | 20 |
| Wing S (Senior) | 150 |
| Wing J (Junior) | 50 |
| Wing H (Hostel) | 25 |

---

**(i) Suggest the best wired medium and draw the cable layout to efficiently connect various wings of Multipurpose Public School, Bangluru.**

**Answer:**

**Best Wired Medium:** Optical Fibre Cable / CAT5 / CAT6 / CAT7 / CAT8 / Ethernet Cable

**Cable Layout (Minimum Spanning Tree — shortest connections):**

[Diagram: Network layout showing optimal cable connections]

```
SENIOR (S) ←——100m——→ ADMIN (A)
    |                      |
  100m                   200m
    |                      |
HOSTEL (H)          JUNIOR (J)
```

**Optimal connections:**
- **A ↔ S**: 100 m ✓ (shortest from A)
- **S ↔ H**: 100 m ✓ (shortest to H)
- **A ↔ J**: 200 m ✓ (shortest to J)

**Total cable length = 100 + 100 + 200 = 400 m**

---

**(ii) Name the most suitable wing where the Server should be installed. Justify your answer.**

**Answer:** **Wing S (Senior)**

**Justification:** Wing Senior has the **maximum number of computers (150)**. Installing the server at the wing with the most workstations minimizes network traffic and reduces average access time for the majority of users.

---

**(iii) Suggest a device/software and its placement that would provide data security for the entire network of the School.**

**Answer:**

- **Device/Software:** **Firewall**
- **Placement:** Installed along with the **Server at Wing Senior (S)**

**Solution:** A firewall monitors and controls incoming and outgoing network traffic based on security rules. Placing it at the server ensures all network traffic passes through security checks.

---

**(iv) Suggest a device and the Protocol that shall be needed to provide wireless Internet access to all smartphone/laptop users in the campus.**

**Answer:**

| Component | Suggestion |
|-----------|-----------|
| **Device** | WiFi Router / WiMax / RF Router / Wireless Modem / RF Transmitter |
| **Protocol** | WAP / 802.11 / TCP/IP / VOIP / MACP / 802.16 |

**Solution:**
- A **WiFi Router** (using **802.11 protocol**) would be the most common and suitable device to provide wireless Internet access across the campus
- Multiple routers/access points may be needed to cover all wings given the distances involved

---

*End of Question Paper*